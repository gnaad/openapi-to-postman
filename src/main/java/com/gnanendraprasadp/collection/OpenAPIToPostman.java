package com.gnanendraprasadp.collection;

import org.json.JSONArray;
import org.json.JSONObject;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.*;
import org.springframework.web.client.RestTemplate;

@Configuration
public class OpenAPIToPostman implements CommandLineRunner {

    @Value("${spring.postman.enabled:false}")
    private boolean enabled;

    /**
     * If set to true, All collections with same name will be dropped and updated collection will be imported.<br>
     * If set to false, collection with same name will be repeated.<br>
     * Suggestion: If versions is not required, set to true.
     */
    @Value("${spring.postman.collection.update:false}")
    private boolean updateStrategy;

    /**
     * Required
     * Get API Key from <a href="https://web.postman.co/settings/me/api-keys">here</a>
     */
    @Value("${spring.postman.apiKey}")
    private String apiKey;

    @Value("${spring.postman.api-docs.path:/v3/api-docs}")
    private String endpoint;

    @Value("${spring.postman.workspace.name:Spring Boot Generated}")
    private String workspaceName;

    @Value("${spring.postman.workspace.type:personal}")
    private String workspaceType;

    @Value("${spring.postman.workspace.id:}")
    private String workspaceId;

    @Value("${spring.postman.workspace.description:A workspace generated by Spring Boot in order to sync collections.}")
    private String workspaceDescription;

    private static final Log log = LogFactory.getLog(OpenAPIToPostman.class);

    private static final String GET_USER_DETAILS = "https://api.getpostman.com/me";
    private static final String CREATE_WORKSPACE = "https://api.getpostman.com/workspaces";
    private static final String DELETE_COLLECTION = "https://api.getpostman.com/collections/";
    private static final String GET_ALL_COLLECTION = "https://api.getpostman.com/collections?workspace=";
    private static final String IMPORT_COLLECTION = "https://api.getpostman.com/import/openapi?workspace=";

    private static final String USER = "user";
    private static final String WORKSPACE = "workspace";
    private static final String COLLECTION = "collection";
    private static final String COLLECTIONS = "collections";

    private static final String FULL_NAME = "fullName";
    private static final String USERNAME = "username";
    private static final String EMAIL = "email";

    private static final String NAME = "name";
    private static final String DESCRIPTION = "description";

    private static final String ID = "id";
    private static final String UID = "uid";
    private static final String INFO = "info";
    private static final String TITLE = "title";

    private static final String TYPE = "type";
    private static final String JSON = "json";
    private static final String INPUT = "input";

    private static final String BOOT_URL = "http://localhost:8080";

    @Override
    public void run(String... args) {
        log.info("Checking postman collection import enabled or not.");
        if (enabled) {
            log.info("Postman collection import enabled.");
            checkSwaggerDocs();
        } else {
            log.info("Postman collection import not enabled.");
        }
    }

    private void checkSwaggerDocs() {
        log.info("Calling api-docs url");
        if (getRequest(BOOT_URL + endpoint).getStatusCode().is2xxSuccessful()) {
            log.info("Connection with api-docs created successfully.");
            checkApiKey();
        } else {
            log.error("Please check your api-docs url correctly.");
        }
    }

    private void checkApiKey() {
        log.info("Checking API key");
        if (apiKey.trim().isEmpty()) {
            log.error("API key is empty.");
        } else {
            log.info("API key fetched successfully.");
            String response = callAPI(HttpMethod.GET, GET_USER_DETAILS, "").getBody();
            if (response != null) {
                JSONObject object = new JSONObject(response);
                if (object.get(USER) != null) {
                    log.info("Fetching user details from API key.");
                    String fullName = object.getJSONObject(USER).get(FULL_NAME).toString();
                    String username = object.getJSONObject(USER).get(USERNAME).toString();
                    String email = object.getJSONObject(USER).get(EMAIL).toString();
                    log.info("FullName: " + fullName);
                    log.info("Username: " + username);
                    log.info("Email: " + email);
                    createWorkspace();
                } else {
                    log.error("Error while fetching user details: " + object);
                }
            } else {
                log.error("Unable to contact Postman API.");
            }
        }
    }

    private void createWorkspace() {
        log.info("Checking workspaceId present or not.");
        if (workspaceId.trim().isEmpty()) {
            log.info("WorkspaceId not present. So creating new workspace.");
            JSONObject body = new JSONObject();
            JSONObject nestedObject = new JSONObject();
            nestedObject.put(NAME, workspaceName);
            nestedObject.put(TYPE, workspaceType);
            nestedObject.put(DESCRIPTION, workspaceDescription);
            body.put(WORKSPACE, nestedObject);
            String response = callAPI(HttpMethod.POST, CREATE_WORKSPACE, body.toString()).getBody();
            if (response != null) {
                JSONObject object = new JSONObject(response);
                if (object.get(WORKSPACE) != null) {
                    log.info("Workspace created successfully with details " + body);
                    createCollection(object, "");
                } else {
                    log.error("Error while creating workspace: " + object);
                }
            } else {
                log.error("Unable to contact Postman API.");
            }
        } else {
            log.info("WorkspaceId present.");
            createCollection(new JSONObject(), workspaceId);
        }
    }

    private void createCollection(JSONObject json, String workspaceId) {
        String id = "";
        if (!workspaceId.trim().isEmpty()) {
            id = workspaceId;
        } else {
            id = json.getJSONObject(WORKSPACE).get(ID).toString();
        }
        String openApi = getRequest(BOOT_URL + endpoint).getBody();
        if (openApi != null) {

            if (updateStrategy) {
                log.info("Collection update strategy is enabled.");
                JSONObject apiDocs = new JSONObject(openApi);
                String apiTitle = apiDocs.getJSONObject(INFO).get(TITLE).toString();
                String getAllCollection = callAPI(HttpMethod.GET, GET_ALL_COLLECTION + id, "").getBody();
                if (getAllCollection != null) {
                    JSONObject collection = new JSONObject(getAllCollection);
                    JSONArray array = collection.getJSONArray(COLLECTIONS);
                    for (int i = 0; i < array.length(); i++) {
                        String collectionTitle = array.getJSONObject(i).getString(NAME);
                        String uid = array.getJSONObject(i).getString(UID);
                        if (apiTitle.equalsIgnoreCase(collectionTitle)) {
                            log.info("Collection with same name found. Removing collection: " + collectionTitle);
                            String response = callAPI(HttpMethod.DELETE, DELETE_COLLECTION + uid, "").getBody();
                            if (response != null) {
                                JSONObject object = new JSONObject(response);
                                if (object.get(COLLECTION) != null) {
                                    log.info("Old collection removed successfully.");
                                } else {
                                    log.error("Error while deleting collection: " + object);
                                }
                            } else {
                                log.error("Unable to contact Postman API.");
                            }
                        }
                    }
                } else {
                    log.error("Error while getting created collection");
                }
            }

            log.info("Creating collection.");
            JSONObject body = new JSONObject();
            body.put(TYPE, JSON);
            body.put(INPUT, new JSONObject(openApi));
            String response = callAPI(HttpMethod.POST, IMPORT_COLLECTION + id, body.toString()).getBody();
            if (response != null) {
                JSONObject object = new JSONObject(response);
                if (object.get(COLLECTIONS) != null) {
                    log.info("Collection created successfully.");
                } else {
                    log.error("Error while creating collection: " + object);
                }
            } else {
                log.error("Unable to contact Postman API.");
            }
        } else {
            log.info("There is some problem while connecting to api-docs");
        }
    }

    private ResponseEntity<String> getRequest(String url) {
        RestTemplate restTemplate = new RestTemplate();
        return restTemplate.getForEntity(url, String.class);
    }

    private ResponseEntity<String> callAPI(HttpMethod method, String url, String body) {
        ResponseEntity<String> response = null;
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = new HttpHeaders();
        headers.add("X-API-Key", apiKey);
        headers.setContentType(MediaType.APPLICATION_JSON);
        if (method == HttpMethod.GET) {
            HttpEntity<Object> entity = new HttpEntity<>(headers);
            response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
        } else if (method == HttpMethod.POST) {
            HttpEntity<Object> entity = new HttpEntity<>(body, headers);
            response = restTemplate.postForEntity(url, entity, String.class);
        } else if (method == HttpMethod.DELETE) {
            HttpEntity<Object> entity = new HttpEntity<>(headers);
            response = restTemplate.exchange(url, HttpMethod.DELETE, entity, String.class);
        }
        return response;
    }
}
